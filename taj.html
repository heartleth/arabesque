<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            html,body{overflow:hidden;margin:0 !important;padding:0 !important;}
            canvas{position:fixed;left:0;top:0;width:100%;height:100%;z-index:-10;}
        </style>
        <title>Document</title>
        <script src="./writer.js"></script>
        <script src="./letter.js"></script>
        <script src="./chars.js"></script>
        <script src="./quran.js"></script>
    </head>
    <body>
        <button onclick="writequran()">al-fatiha</button>
        <p style="text-align: center;"></p>
        <canvas></canvas>
        <script>
            const canvas = document.querySelector('canvas');
            const cursor = document.querySelector('#cursor');
            let sentence = [];
            let ctx = canvas.getContext('2d');
            let scrollX = 0;
            let canvassizeX;
            let sentencelength = 0;
            let x, y;
            let zoom = 1;

            let pathMap = [];

            const drawSentence = () => {
                sentencelength = 0;
                pathMap = [];
                let strokeX = canvassizeX - 50;
                let mode = 'initial';
                let i = 0;

                let pth = new Path2D();
                let ret = 0;
                mode = 'initial';
                i = 0;

                pth.moveTo(canvassizeX, y);
                pth.lineTo(strokeX, y);
                for (const letter of sentence) {
                    if (mode == 'initial' && (sentence.length - 1 == i || sentence[i+1] == ' ')) {
                        mode = 'isolated';
                    }
                    let next = getLetter({
                        x: strokeX,
                        y
                    }, letter, mode, false, zoom);
                    pathMap.push(next);
                    pth.addPath(next.path);
                    for (const dot of next.dots) {
                        ctx.lineWidth = 15;
                        ctx.beginPath();
                        ctx.moveTo(dot[0] + 5.5, dot[1] + 5.5);
                        ctx.lineTo(dot[0] - 5.5, dot[1] - 5.5);
                        ctx.stroke();
                    }
                    strokeX -= next.move;
                    sentencelength += next.move;
                    ret = next.move;
                    ++i;
                    pathMap[pathMap.length-1]._mode = mode;
                    mode = next.mode == 'initial' && (i == sentence.length - 1 || sentence[i+1] == ' ') ? 'isolated' : next.mode;
                    mode = next.mode == 'medial' && (i == sentence.length - 1 || sentence[i+1] == ' ') ? 'final' : next.mode;
                }
                pth.moveTo(strokeX, y);
                pth.lineTo(0, y);

                ctx.lineWidth = 10;
                ctx.stroke(pth);
            }
            const render = async () => {
                canvas.width = document.body.clientWidth;
                flX = x = (canvassizeX = document.body.clientWidth) / 2;
                x += scrollX;
                canvas.height = window.innerHeight;
                flY = y = window.innerHeight / 2;
                ctx = canvas.getContext('2d');

                drawSentence();
            };

            let isMouseOn = false;
            let mouseBegin = 0;
            let mouseBeginAt = -1;
            let mouseEnd = 0;
            let flX, fly;
            let interval;
            let ex, ey;
            let pullWidth = 100;
            let scrollspeed = 0;
            let moving = false;

            canvas.onmousedown = canvas.ontouchstart = e => {
                console.log(e);
                drawSentence();
                mouseBeginAt = -1;
                isMouseOn = true;
                mouseBegin = {
                    x: flX = e.x,
                    y: flY = e.y
                };
                flX = e.x;
                flY = e.y;
                interval = setInterval(() => {
                    flX += (ex - flX);
                    flY += (ey - flY);
                    ctx.clearRect(0, 0, 9999, 9999);
                    let strokeX = canvassizeX - 50;
                    let i = 0;
                    let dots;

                    ctx.beginPath();
                    ctx.moveTo(canvassizeX, y);
                    ctx.lineTo(strokeX, y);
                    ctx.stroke();
                    for (const letter of pathMap) {
                        ctx.lineWidth = 10;
                        if (strokeX > mouseBegin.x && mouseBegin.x > strokeX - letter.move) {
                            mouseBegin.x = (strokeX - 0.5 * letter.move);
                            mouseBeginAt = i;
                            pullWidth = letter.move / 2;

                            const alphabet = getAlphabet(mouseBeginAt, sentence, flX - mouseBegin.x, mouseBegin.y - flY);
                            const mode = (pathMap[i] ?? {})._mode == 'initial'
                                ? (i == sentence.length - 1 || sentence[i+1]==' ' ? 'isolated' : 'initial')
                                : (letter.mode == 'medial' || letter._mode == 'final') && (i == sentence.length - 1 || sentence[i+1]==' ') ? 'final' : letter.mode;

                            const info = getLetter({x: strokeX, y}, alphabet, mode);
                            ctx.setLineDash([10, 15]);
                            ctx.stroke(alphabet ? info.path : letter.path);
                            ctx.setLineDash([]);
                            dots = alphabet ? info.dots : letter.dots;
                        } else {
                            ctx.stroke(letter.path);
                            dots = letter.dots;
                        }

                        for (const dot of dots) {
                            ctx.lineWidth = 15;
                            ctx.beginPath();
                            ctx.moveTo(dot[0] + 5.5, dot[1] + 5.5);
                            ctx.lineTo(dot[0] - 5.5, dot[1] - 5.5);
                            ctx.stroke();
                        }
                        strokeX -= letter.move;
                        i++;
                    }
                    ctx.beginPath();
                    ctx.moveTo(strokeX, y);
                    ctx.lineTo(0, y);
                    ctx.lineWidth = 10;
                    ctx.stroke();

                    if (mouseBeginAt == -1) {
                        const alphabet = getAlphabet(-1, sentence, flX - mouseBegin.x, mouseBegin.y - flY);
                        ctx.setLineDash([10, 15]);
                        const info = getLetter({x: strokeX, y}, alphabet, (pathMap[pathMap.length-1] ?? {mode:'initial'}).mode == 'initial' ? 'isolated' : 'final');
                        ctx.stroke(info.path);
                        ctx.lineWidth = 15;
                        for (const dot of info.dots) {
                            ctx.beginPath();
                            ctx.moveTo(dot[0] + 5.5, dot[1] + 5.5);
                            ctx.lineTo(dot[0] - 5.5, dot[1] - 5.5);
                            ctx.stroke();
                        }
                        ctx.lineWidth = 10;
                        ctx.setLineDash([]);
                    }
                }, 16);
            }
            canvas.onmouseup = canvas.ontouchend = e => {
                isMouseOn = false;
                mouseEnd = {
                    x: e.x,
                    y: e.y
                };
                clearInterval(interval);

                if (!(Math.abs(mouseEnd.x - mouseBegin.x) < 10 && Math.abs(mouseEnd.y - mouseBegin.y) < 10)) {
                    const offsetX = mouseEnd.x - mouseBegin.x;
                    const offsetY = mouseBegin.y - mouseEnd.y;
                    const alphabet = getAlphabet(mouseBeginAt, sentence, offsetX, offsetY);
                    if (alphabet !== undefined) {
                        if (mouseBeginAt == -1) {
                            sentence.push(alphabet);
                        } else {
                            sentence[mouseBeginAt] = alphabet;
                        }
                    }
                }

                ctx.clearRect(0, 0, 9999, 9999);
                drawSentence();
                document.querySelector('p').innerText = sentence.map(e => chars[e]).join('');
            }
            canvas.onmousemove = canvas.ontouchmove = e => {
                if (isMouseOn) {
                    ex = e.x;
                    ey = e.y;
                }
            };
            window.onpointerwheel = e => {
                if (!isMouseOn) {
                    scrollspeed += e.deltaY / 5;
                    render();
                }
            };

            async function writequran() {
                let index = 0;
                sentence=[];
                s=quran[index][0];
                scrollX = 0;
                for (const s of quran[index]) {
                    sentence = [];
                    let list = [...s].map(e=>chars_invert[e]);
                    for (let e of list) {
                        if (e) {
                            sentence.push(e);
                            ctx.clearRect(0, 0, 9999, 9999);
                            // getLetter([0, 0], e, (pathMap[pathMap.length-1] ?? {mode:'initial'}).mode == 'initial' ? 'isolated' : 'final', true, zoom).move;
                            drawSentence();
                            await new Promise(e=>setTimeout(_=>e(0), 100));
                        }
                    }
                    await new Promise(e=>setTimeout(_=>e(0), 3000));
                }
            }

            window.onload = () => {
                render();
            }
            window.onresize = () => {
                render();
            };
            window.onkeydown = e => {
                if (e.code == 'Space') {
                    sentence.push(' ');
                    render();
                }
                if (e.code == 'Backspace') {
                    sentence.pop();
                    render();
                }
            };
            setInterval(() => {
                scrollX += scrollspeed;
                scrollspeed = scrollspeed * 0.8;
                let offset = canvassizeX / 3;
                if (scrollX > sentencelength / 2 - offset) {
                    scrollspeed = 0;
                    scrollX = sentencelength / 2 - offset;
                    render();
                }
                if (scrollX < -sentencelength / 2 + offset) {
                    scrollspeed = 0;
                    scrollX = -sentencelength / 2 + offset;
                    render();
                }
                if (scrollspeed != 0) {
                    render();
                }
                if (Math.abs(scrollspeed) < 1) {
                    scrollspeed = 0;
                }
            }, 16);
        </script>
    </body>
</html>